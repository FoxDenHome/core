{ nixpkgs, foxDenLib, ... }:
let
  util = foxDenLib.util;
  eSA = nixpkgs.lib.strings.escapeShellArg;

  interfaceType = with nixpkgs.lib.types; submodule {
    options = {
      driver = nixpkgs.lib.mkOption {
        type = enum (nixpkgs.lib.attrsets.attrNames foxDenLib.hosts.drivers);
      };
      driverOpts = nixpkgs.lib.mkOption {
        type = attrsOf anything; # TODO: Host driver schema
        default = {};
      };
      dns = {
        name = nixpkgs.lib.mkOption {
          type = str;
          default = "";
        };
        cnames = nixpkgs.lib.mkOption {
          type = listOf str;
          default = [];
        };
        zone = nixpkgs.lib.mkOption {
          type = str;
          default = "foxden.network";
        };
        ttl = nixpkgs.lib.mkOption {
          type = ints.positive;
          default = 3600;
        };
        dynDns = nixpkgs.lib.mkOption {
          type = bool;
          default = false;
        };
        dynDnsTtl = nixpkgs.lib.mkOption {
          type = nullOr ints.positive;
          default = 300;
        };
      };
      addresses = nixpkgs.lib.mkOption {
        type = listOf foxDenLib.types.ip;
      };
      routes = nixpkgs.lib.mkOption {
        type = nullOr (listOf routeType);
        default = [];
      };
    };
  };

  routeType = with nixpkgs.lib.types; submodule {
    options = {
      Destination = nixpkgs.lib.mkOption {
        type = nullOr foxDenLib.types.ip;
        default = null;
      };
      Gateway = nixpkgs.lib.mkOption {
        type = nullOr foxDenLib.types.ipWithoutCidr;
        default = null;
      };
    };
  };

  hostType = with nixpkgs.lib.types; submodule {
    options = {
      interfaces = nixpkgs.lib.mkOption {
        type = attrsOf interfaceType;
      };
      nameservers = nixpkgs.lib.mkOption {
        type = listOf str;
        default = [];
      };
    };
  };

  getByName = (config: name: let
    namespace = "host-${name}";
  in {
    inherit name;
    namespace = namespace;
    namespacePath = "/run/netns/${namespace}";
    unit = "netns-host-${name}.service";
    resolvConf = "/etc/foxden/hosts/${name}/resolv.conf";
    suffix = util.mkHash8 name;
  } // config.foxDen.hosts.hosts.${name});
in
{
  getByName = getByName;

  nixosModule = ({ config, pkgs, foxDenLib, ... }:
  let
    hosts = map (getByName config) (nixpkgs.lib.attrsets.attrNames config.foxDen.hosts.hosts);
    mapIfaces = (host: map ({ name, value }: value // { inherit host name; suffix = util.mkHash8 (host.name + "|" + name); }) (nixpkgs.lib.attrsets.attrsToList host.interfaces));
    interfaces = nixpkgs.lib.flatten (map mapIfaces hosts);

    ifaceHasV4 = (iface: nixpkgs.lib.any (addr: util.isIPv4 addr) iface.addresses);
    ifaceHasV6 = (iface: nixpkgs.lib.any (addr: util.isIPv6 addr) iface.addresses);

    ifaceHasInternal = (iface: nixpkgs.lib.any (addr: util.isPrivateIP addr) iface.addresses);
    ifaceHasExternal = (iface: nixpkgs.lib.any (addr: addr: !(util.isPrivateIP addr)) iface.addresses);

    mkIfaceDynDnsOne = (iface: check: type: value: if (check iface) then [
      {
        zone = iface.dns.zone;
        name = iface.dns.name;
        type = type;
        ttl = iface.dns.dynDnsTtl;
        value = value;
        dynDns = true;
        horizon = "external";
      }
    ] else []);

    mkIfaceDynDns = (iface: if iface.dns.dynDns then
      (mkIfaceDynDnsOne iface ifaceHasV4 "A" "127.0.0.1") ++
      (mkIfaceDynDnsOne iface ifaceHasV6 "AAAA" "fe80::1")
    else []);

    mkIfaceCname = (iface: check: horizon: if (check iface) then (map (cname: {
      zone = iface.dns.zone;
      name = cname;
      type = "CNAME";
      ttl = iface.dns.ttl;
      value = foxDenLib.global.dns.mkHost iface.dns;
      horizon = horizon;
    }) iface.dns.cnames) else []);
  in
  {
    options.foxDen.hosts = with nixpkgs.lib.types; {
      hosts = nixpkgs.lib.mkOption {
        type = attrsOf hostType;
        default = {};
      };
    };

    config = {
      foxDen.dns.records = nixpkgs.lib.flatten (map
          (iface: let
            mkRecord = (addr: nixpkgs.lib.mkIf (iface.dns.name != "") {
              zone = iface.dns.zone;
              name = iface.dns.name;
              type = if (util.isIPv6 addr) then "AAAA" else "A";
              ttl = iface.dns.ttl;
              value = util.removeIPCidr addr;
              horizon = if (util.isPrivateIP addr) then "internal" else "external";
            });
          in
          (
            (map mkRecord iface.addresses)
            ++ (mkIfaceDynDns iface)
            ++ (mkIfaceCname iface ifaceHasInternal "internal")
            ++ (mkIfaceCname iface ifaceHasExternal "external")
          ))
        interfaces);

      environment.etc = nixpkgs.lib.listToAttrs (map (host: {
        name = nixpkgs.lib.strings.removePrefix "/etc/" host.resolvConf;
        value.text = ''
          # Generated by foxDen
          ${nixpkgs.lib.concatMapStrings (ns: "nameserver ${ns}\n") host.nameservers}
        '';
      }) hosts);

      systemd = nixpkgs.lib.mkMerge (
        (map ({ name, value } : (value.build {
          interfaces = (nixpkgs.lib.filter (iface: iface.driver == name) interfaces);
        }).config.systemd) (nixpkgs.lib.attrsets.attrsToList foxDenLib.hosts.drivers))
        ++ [{
          # Configure each host's NetNS
          services = (nixpkgs.lib.attrsets.listToAttrs (map (host: let
            ipCmd = eSA "${pkgs.iproute2}/bin/ip";
            ipInNsCmd = "${ipCmd} netns exec ${eSA host.namespace} ${ipCmd}";

            renderRoute = (dev: route: "${ipInNsCmd} route add " + (if route.Destination != null then eSA route.Destination else "default") + (if route.Gateway != null then " via ${eSA route.Gateway}" else " dev ${eSA dev}"));

            mkInterfaceStartConfig = (interface: let
              ifaceDriver = foxDenLib.hosts.drivers.${interface.driver};
              serviceInterface = (ifaceDriver.serviceInterface or (interface: "host${interface.suffix}")) interface;
              driverRunParams = { inherit ipCmd ipInNsCmd serviceInterface interface; };
            in
              (ifaceDriver.execStart driverRunParams)
                ++ [ "${ipCmd} link set ${eSA serviceInterface} netns ${eSA host.namespace}" ]
                ++ (map (addr:
                      "${ipInNsCmd} addr add ${eSA addr} dev ${eSA serviceInterface}")
                      interface.addresses)
                ++ [ "${ipInNsCmd} link set ${eSA serviceInterface} up" ]
                ++ (map (renderRoute serviceInterface) interface.routes)
            );
          in
          {
            name = (nixpkgs.lib.strings.removeSuffix ".service" host.unit);
            value = {
              description = "NetNS ${host.namespace}";
              unitConfig = {
                After = [ "network-pre.target" ];
              };
              serviceConfig = {
                Type = "oneshot";
                RemainAfterExit = true;

                ExecStart = [
                  "-${ipCmd} netns del ${eSA host.namespace}"
                  "${ipCmd} netns add ${eSA host.namespace}"
                  "${ipInNsCmd} addr add 127.0.0.1/8 dev lo"
                  "${ipInNsCmd} addr add ::1/128 dev lo noprefixroute"
                  "${ipInNsCmd} link set lo up"
                ]
                ++ (nixpkgs.lib.flatten (map mkInterfaceStartConfig (nixpkgs.lib.filter (iface: iface.host.name == host.name) interfaces)));

                ExecStop = [
                  "${ipCmd} netns del ${eSA host.namespace}"
                ];
              };
            };
          }) hosts));
        }
      ]);
    };
  });
}
